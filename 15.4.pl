#!/usr/bin/perl -w

use 5.10.0;
# use CGI;
# use Encode qw(decode_utf8);
# use Encode qw(decode encode);
# BEGIN{@ARGV=map Encode::decode($_, 1),@ARGV;}
# BEGIN{@ARGV = map decode_utf8($_, 1), @ARGV;}
# use open qw(:std :encoding(UTF-8));
# use Encode::Locale;
# use Encode;
# use Time::Moment;
# use diagnostics;


use strict;
use warnings FATAL => 'all';
use utf8;
binmode(STDIN, ':utf8');
binmode(STDOUT, ':utf8');
use utf8::all 'GLOBAL';
use DDP;
use Data::Dumper;


# File 15.4.pl
# https://github.com/chicagoist/Exercises_From_LearningPerl.git
# https://www.learning-perl.com/
# https://www.linkedin.com/in/legioneroff/


# Используя given и умные сравнения, напишите программу для вывода
# всех делителей числа, переданного в командной строке (кроме 1 и самого числа).
# Например, для числа 99 программа должна выдать делители 3, 9, 11 и 33.
# Если число является простым (т. е. не имеет таких делителей), программа
# должна сообщить об этом. Если аргумент командной строки  не является числом,
# программа выдает сообщение об ошибке и не пытается вычислять делители.
# Хотя задачу можно решить при помощи конструкций if с обычными сравнениями,
# используйте только умные сравнения.
# Для начала приведем пользовательскую функцию, возвращающую список делителей.
# Функция последовательно проверяет все числа от 1 до половины $number:



sub divisors {
    my $number = shift;
    my @divisors = ();
    my $divisor;
    use experimental 'switch'; # require for given

    if ($number ~~ /^-?\d+$/) { # Если аргумент командной строки  не является числом,
        # программа выдает сообщение об ошибке и не пытается вычислять делители.
        foreach $divisor (2 .. $number / 2) {
            push @divisors, $divisor unless $number % $divisor;
        }
    }else {
        use utf8::all 'GLOBAL';
        die "аргумент командной строки  не является числом";
    }
       return @divisors
           if (@divisors != 0);
}




sub divisors_of_number {
    chomp @ARGV;
    my @divisors_of_argv = divisors($ARGV[0]);
    use experimental 'switch'; # require for given

    for(@divisors_of_argv){
        given ($_){
        when($_ == $ARGV[0] || $ARGV[0] == 1) {say "кроме $ARGV[0]"; exit}
        when($_ == 0 ) {say "число является простым (т. е. не имеет таких делителей)"; exit}
        when($_ != 0 ) {print "Divisors of $ARGV[0] : " , join(", ", @divisors_of_argv), "\n"; exit}
        }
    }
}

divisors_of_number();


=begin text

 $ perl 15.4.pl 99
 Divisors of 99 : 3, 9, 11, 33

 $ perl 15.4.pl 12
 Divisors of 12 : 2, 3, 4, 6

 $ perl 15.4.pl 11
 число является простым (т. е. не имеет таких делителей)

 $ perl 15.4.pl 1
 кроме 1

 $ perl 15.4.pl 0
 кроме 0

 $ perl 15.4.pl six
 аргумент командной строки  не является числом at 15.4.pl line 55.

=end text

=cut


# Верный ответ из книги:

# Одно из возможных решений, использующее given и умное сравнение:

# say "Checking the number <$ARGV[0]>";
# given( $ARGV[0] ) {
#  when( ! /^\d+$/ ) { say "Not a number!" }
#  my @divisors = divisors( $_ );
#  my @empty;when( @divisors ~~ @empty ) { say "Number is prime" }
#  default { say "$_ is divisible by @divisors" }
# }
# sub divisors {
# my $number = shift;
# my @divisors = ();
# foreach my $divisor ( 2 .. $number/2 ) {
#    push @divisors, $divisor unless $number % $divisor;
# }
#    return @divisors;
# }
# Сначала программа сообщает, с каким числом она работает; всегда полезно
# лишний раз убедиться в этом. Значение $ARGV[0]  заключается в угловые
# скобки, чтобы отделить его от остальных символов строки.
# Конструкция given  содержит пару блоков when, рядом с которыми
# размещаются другие команды. Первое условие when  проверяет, что введенная
# строка является числом; для этого к ней применяется регулярное выражение,
# совпадающее с последовательностью цифр. Если регулярное выражение не совпадает,
# программа выводит соQ общение о том, что строка не является числом. Условие
# when содержит неявную команду break, которая прерывает выполнение given.
# Если проверка успешно пройдена, вызывается функция divisors(). То же самое можно
# было сделать и вне given, но если программа выполняется для нечисловой строки
# (например, если пользователь ввел строку 'Fred'), Perl выдаст предупреждение.
# Наш способ предотвращает выдачу предупреждения, а when  выполняет функции
# сторожевого условия. После получения делителей мы хотим знать, содержит ли массив
# @divisors хотя бы один элемент. Конечно, можно было бы использовать массив в
# скалярном контексте для получения количества элеQ ментов, но по условиям необходимо
# использовать умные сравнения. Как известно, два сравниваемых массива считаются
# равными только в том случае, если они содержат одни и те же элементы, следующие в
# одинаковом  порядке. Мы создаем  пустой массив @empty, не содержащий ни одного
# элемента. При сравнении с @divisors  умное сравнение завершится успешно только
# при отсутствии делителей. Если это условие истинно, выполняется блок when,
# который также содержит неявную команду break. Наконец, если число не является простым,
# выполняется блок default, который выводит количество делителей. И небольшое добавление,
# о котором в этой книге упоминать не следовало бы, потому  что ссылки будут
# рассматриваться только в «Intermediate Perl» 1 : при проверке @divisors на наличие
# элементов мы выполнили лишнюю работу, создавая пустой именованный массив для сравнения.
# С таким же успехом можно было воспользоваться анонимным массивом и обойтись без
# лишнего шага:
# when( @divisors ~~ [] ) { ... }