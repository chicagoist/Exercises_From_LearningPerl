#!/usr/bin/perl -w

use 5.10.0;
# use CGI;
# use POSIX;
# use Encode qw(decode_utf8);
# use Encode qw(decode encode);
# BEGIN{@ARGV=map Encode::decode($_,1),@ARGV;}
# BEGIN{@ARGV = map decode_utf8($_, 1), @ARGV;}
# use open qw(:std :encoding(UTF-8));
# use utf8::all 'GLOBAL';
# use Encode::Locale;
# use Encode;
# use diagnostics;


use strict;
use warnings FATAL => 'all';
use utf8;
binmode(STDIN, ':utf8');
binmode(STDOUT, ':utf8');
use DDP;
use Data::Dumper;
use Bundle::Camelcade;


# СТРОКИ И СОРТИРОВКА


{
    # Поиск подстроки по индексу

    # функция index поможет вам в поисках. Вот как это делается:
    #    $where = index($big, $small);
    # Perl находит первое вхождение подстроки и возвращает целочисленный индекс первого символа.
    # Нумерация индексов начинается с нуля – если подстрока находится в самом начале строки,
    # функция index  возвращает 0.
    # Если подстрока смещена на один символ, функция возвращает 1,
    # и т. д. Если найти подстроку не удалось, функция сообщает об этом, возвращая –1.
    # В следующем примере $where возвращает 6:
    my $stuff = "Howdy world!";
    my $where = index($stuff, "wor");
    print "\$where = $where\n";

    # Функция index  всегда возвращает позицию первого вхождения подстроки.
    # Однако ей можно приказать начать поиск не от начала строки, а с более поздней позиции –
    # для этого функции передается необязательный третий параметр:
    print(my $where1 = index($stuff, "w")); # $where1 присваивается 2
    say "";
    print my $where2 = index($stuff, "w", $where1 + 1); # $where2 присваивается 6
    say "";
    print my $where3 = index($stuff, "w", $where2 + 1); # $where3 присваивается -1# (подстрока не найдена)
    say "";


    # В некоторых ситуациях требуется найти не первое, а последнее вхождение подстроки.
    # Эта задача решается функцией rindex.
    # В следующем примере  функция ищет последнее вхождение  /,
    # которое обнаруживается в позиции 4:
    print my $last_slash = rindex("/etc/passwd", "/"); # Значение равно 4
    say "";

    # Функция rindex  также имеет необязательный третий параметр,
    # но вэтом случаеон определяетмаксимальное допустимое  возвращаемое
    # значение:
    my $fred = "Yabba dabba doo!";
    my $where11 = rindex($fred, "abba");               # $where11 gets 7
    my $where22 = rindex($fred, "abba", $where11 - 1); # $where22 присваивается 1
    my $where33 = rindex($fred, "abba", $where2 - 1);  # $where3 присваивается -1

}

{
    # ОПЕРАЦИИ С ПОДСТРОКАМИ И ФУНКЦИЯ substr

    # Функция substr работает с подмножеством символов большей строки.
    # Синтаксис вызова выглядит так:

    # $part = substr($string, $initial_position, $length);

    # Функция получает три аргумента: строку, отсчитываемую от нуля начальную
    # позицию (по аналогии с возвращаемым значением index) и длину подстроки.
    # Возвращаемое значение представляет собой заданную подстроку:
    my $mineral = substr("Fred J. Flintstone", 8, 5); # "Flint"
    my $rock = substr "Fred J. Flintstone", 13, 1000; # "stone"

    # чтобы подстрока завершалась в конце основной строки (независимо от ее фактической длины),
    # опустите при вызове третий параметр (длину):
    my $pebble = substr "Fred J. Flintstone", 13; # "stone"

    # В следующем примере позиQ ция –3 соответствует трем символам от конца строки,
    # то есть букве i:
    my $out = substr("some very long string", -3, 2); # $out присваивается "in"
    # Как и следовало ожидать, index и substr удобно использовать совместно.
    # В этом примере из строки извлекается подстрока, начинающаяся с позиции буквы l:
    my $long = "some very very long string";
    my $right = substr($long, index($long, "l"));

    # А  теперь самое  интересное: если строка  хранится в переменной, выбранную часть строки
    # можно изменить:
    my $string = "Hello, world!";
    substr($string, 0, 5) = "Goodbye"; # $string содержит "Goodbye, world!"

    # оператор привязки (=~) позволяет ограничить операцию частью строки.
    # В следующем примере подстрока fred  заменяется подстрокой barney в пределах 20 последних символов:
    substr($string, -20) =~ s/fred/barney/g;

    # также можете использовать substr более традиционным способом – с четырьмя аргументами,
    # в которых четвертый аргумент задает подстроку замены:
    my $previous_value = substr($string, 0, 5, "Goodbye");
    say "\$previous_value = $previous_value";
}

{ # ФОРМАТИРОВАНИЕ ДАННЫХ ФУНКЦИЕЙ sprintf
    use DateTime;
    my $date = DateTime->now(time_zone => 'Europe/Kiev');
    say "\$date = $date";

    # Функция sprintf получает те же аргументы, что и printf (кроме необязательного файлового дескриптора, конечно),
    # но не выводит, а возвращает полученную строку. Например, это позволяет сохранить отформатированную строку
    # в переменной для использования в будущем, либо вам недостаточно возможностей управления выводом,
    # предоставляемых функцией printf:
    my $date_tag = sprintf"%4d/%02d/%02d %2d:%02d:%02d",$date->year, $date->month, $date->day, $date->hour, $date->minute, $date->second;
    say "\$date_tag = $date_tag";

    # Начальный нуль в коде формата означает, что число должно дополняться начальными нулями до заданной ширины.
    # Без начальных нулей полученная строка даты/времени содержала бы нежелательные начальные пробелы вместо нулей:
    # "2021/ 2/31 8: 6: 4"
}

{# ИСПОЛЬЗОВАНИЕ ФУНКЦИИ sprintf для ВЫВОДА ДЕНЕЖНЫХ СУММ

    # Например, денежные суммы должны выводиться в виде 2.50, но не 2.5 – и конечно, не 2.49997!
    # Задача легко решается при помощи формата "%.2f":
    my $money = sprintf "%.2f", 2.49997;
    say "\$money = $money";

    # Если выводимое число достаточно велико, для разделения разрядов запятыми
    # (например, если это денежная сумма) можно создать удобную пользовательскую
    # функцию:
    sub big_money {
        chomp($_ = <STDIN>);
    # my $number = sprintf "%.2f", shift @_;
    my $number = sprintf "%.2f", $_;
    # При каждой итерации цикла добавляется одна запятая
    1 while $number =~ s/^(-?\d+)(\d\d\d)/$1,$2/;
        # same
        # while ($number =~ s/^(-?\d+)(\d\d\d)/$1,$2/) {
        # 1;
        # }
    # Добавляем знак доллара в нужную позицию
    $number =~ s/^(-?)/$1\$/;
    $number, "\n";
}
    print big_money();
}

{# РАСШИРЕННАЯ СОРТИРОВКА
   # Простейшая функция числовой сортировки выглядит так:
    my @some_numbers = (0..100);
     sub by_number {# Функция сортировки, переменные $a и $b уже подготовлены
         if ($a < $b) {
             -1
         } elsif ($a > $b) {
             1
         } else {
             0
         }
     }
    # Чтобы использовать эту функцию при сортировке, укажите ее имя (без префикса &)
    # между ключевым словом sort  и сортируемым списком. В следующем примере
    # отсортированный список чисел помещается в @result:
    my @result = sort by_number @some_numbers;
    say @result;
    # Обратите внимание: в функции сортировки мы не пытаемся объявлять переменные $a  and $b
    # или задавать их значения – если это сделать, функция будет работать неправильно.
    # Мы просто поручаем Perl задать $a и $b, а нам остается лишь написать функцию сравнения.

    # ту же функцию сортировки можно записать в упрощенном виде:
    sub by_numberR { $a <=> $b }
    my @resultT = sort by_numberR @some_numbers;
    print "@result\n";
    # Если оператор <=> сравнивает числа, нетрудно предположить, что и для строк существует свой
    # оператор трехстороннего сравнения:
    #    cmp()

    # Конечно, cmp  сам по себе обеспечивает тот же порядок, что и сортировка по умолчанию.
    # Функцию, которая всего лишь обеспечивает стандартный порядок сортировки, даже не нужно писать:
    my @any_strings = ("привет мир!", "HeLlO wOrLd", "hello world", "HELLO WORLD", "privet world", "ПрИвЕт МиР!","Привет, Мир!");
    sub ASCIIbetically { $a cmp $b }
    my @strings = sort ASCIIbetically @any_strings;
    print"@strings\n";

    sub case_insensitive { "\L$a" cmp "\L$b" }
    @strings = sort case_insensitive @any_strings;
    print"@strings\n";

    # Допустим, список необходимо отсортировать в числовом порядке по убыванию.
    # Задача легко решается при помощи функции reverse:

    my @descending = reverse sort { $a <=> $b } @some_numbers;
    print "@descending\n";

    # Операторы сравнения (<=> иcmp) «близоруки»; они смотрят не на то, какой операнд хранится в $a или в $b,
    # а на то, где он стоит – слева или справа. Таким образом, если переставить $a и $b местами, оператор
    # сравнения будет каждый раз получать обратный результат. Следовательно, числовую сортировку по убыванию
    # можно выполнить и таким способом:
    @descending = sort { $b <=> $a } @some_numbers;
    print "@descending\n";

}

{# СОРТИРОВКА ХЕША ПО ЗНАЧЕНИЯМ
    # Требуется вывести элементы списка в правильном порядке, начиная с победителя,
    # так чтобы хеш был отсортирован по набранным очкам:
    my %score = ("barney" => 195, "fred" => 205, "dino" => 30);
    my @winners = sort by_score keys %score;
    sub by_score { $score{$b} <=> $score{$a} }
    print "\@winners => @winners\n";
}

{# Сортировка по нескольким ключам
    my %scoreE = ("barney" => 195, "fred" => 205,"dino" => 30, "bamm-bamm" => 195, );
    # Как видите, bamm-bamm  набрал одинаковое количество очков с barney.
    # Кто же из них должен стоять первым в отсортированном списке игроков?
    # Неизвестно, потому что оператор сравнения (обнаружив одинаковые значения
    # с обеих сторон) вернет нуль при проверке этой пары.
    my @winners = sort by_scoreE keys %scoreE;
    sub by_scoreE {
        $scoreE{$b} <=> $scoreE{$a} # набранных очков
        or $a cmp $b   # ASCII-алфавитная сортировка по именам
        }
    print "\@winners => @winners\n";

}