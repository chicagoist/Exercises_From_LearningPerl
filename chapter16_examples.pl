#!/usr/bin/perl

use 5.10.0;
# use CGI;
use POSIX;
# use Encode qw(decode_utf8);
# use Encode qw(decode encode);
# BEGIN{@ARGV=map Encode::decode($_,1),@ARGV;}
# BEGIN{@ARGV = map decode_utf8($_, 1), @ARGV;}
# use open qw(:std :encoding(UTF-8));
# use utf8::all 'GLOBAL';
# use Encode::Locale;
# use Encode;
# use diagnostics;


use strict;
use warnings FATAL => 'all';
use utf8;
binmode(STDIN, ':utf8');
binmode(STDOUT, ':utf8');
use utf8::all 'GLOBAL';
use DDP;
use Data::Dumper;
use Bundle::Camelcade;


# УПРАВЛЕНИЕ ПРОЦЕССАМИ

{
    # Функция system

    # Для запуска дочернего процесса в Perl проще всего воспользоваться функцией system.
    # Например, выполнение команды UNIX date  в Perl выглядит так:

    system "date";

    # Дочерний процесс выполняет команду date, которая наследует от Perl стандартные
    # потоки ввода, вывода и ошибок. Это означает, что стандартная строка с датой и
    # временем в коротком формате, выдаваемая date, попадает в тот приемник, с которым
    # в Perl уже связан дескриптор STDOUT.
    # для более сложных команд (скажем, ls –l $HOME) весь текст приQ дется включить
    # в параметр:

    system 'ls -l $HOME';

    # нам пришлось перейти от кавычек к апострофам, так как $HOME является переменной командного процессора.
    # Конечно, нужный знак можно экранировать в строке:

    system "ls -l \$HOME";

    # Если команда «достаточно проста», командный процессор вообще не задействуется.
    # Так, упоминавшиеся ранее команды date  и ls  Perl запускает напрямую,
    # для чего он ищет команду GNU/Linux по унаследованному значению PATH.
    # Но если в строке есть чтоQто необычное (например, метасимволы командного
    # процессора: $, ; или |), для ее обработки активизируется стандартный командный
    # процессор Bourne Shell (/bin/sh ). В этом случае дочерним процессом является
    # командный процессор, а запрашиваемая команда становится «внуком» (или потомком
    # следующего уровня). Например, вы можете  записать в  аргументе целый мини-сценарий
    # командного процессора:

    # DANGEROUS SCRIPT:
    # system 'for i in *; do echo == $i ==; cat $i; done';
    system 'for i in *; do echo == $i ==; ls -l $i; done';

    # Мы снова используем апострофы, потому что знак $  предназначается для командного
    # процессора, а не для Perl. С кавычками Perl заменит $i текущим значением переменной
    # и не позволит командному процессору использовать свое значение.

}

{ #ВЫПОЛНЕНИЕ КОМАНД В ОБХОД КОМАНДНОГО ПРОЦЕССОРА

    # Оператор system  также может вызываться с несколькими аргументами.
    # В этом случае командный процессор не используется, какой бы сложной
    # ни была команда:

    my $root = '/';
    my @dirs = qw(var home);
    system "sh -c 'ls $root'; sh -c 'cd $root; ls -l @dirs'; echo '@dirs'";


}